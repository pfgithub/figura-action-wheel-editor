import type { Avatar, Condition, UUID } from "@/types";

/*
Use Store to store the values
https://figura-wiki.pages.dev/globals/Avatar#store
store(key, value)

Sample code

local mainPage = action_wheel:newPage()
action_wheel:setPage(mainPage)


function pings.bowl()
    animations.model.test1:play()

end


local action = mainPage:newAction()
    :title("Test action1")
    :item("minecraft:dirt")
    :hoverColor(1, 0, 1)
    :onLeftClick(pings.bowl)

vanilla_model.PLAYER:setVisible(false)

function events.tick()
    local crouching = player:getPose() == "CROUCHING"
    local sprinting = player:isSprinting()
    local blocking = player:isBlocking()
    local fishing = player:isFishing()
    local sleeping = player:getPose() == "SLEEPING"
    local swimming = player:getPose() == "SWIMMING"
    local flying = player:getPose() == "FALL_FLYING"
    local walking = player:getVelocity().xz:length() > .01

    animations.model.i:setPlaying(not walking and not crouching)
end

*/

const getHeader = (avatar: Avatar) => /* lua */ `
--------------------------------------
-- This file is generated by --
-- https://pfg.pw/figura-action-wheel-editor

-- Edit it at the website.
--------------------------------------


-- %__DATA_MARKER__%
${JSON.stringify(avatar, null, 2).split("\n").map(l => "-- " + l).join("\n")}
-- %__DATA_MARKER__%


local function dump(o)
   if type(o) == 'table' then
      local s = '{ '
      for k,v in pairs(o) do
         if type(k) ~= 'number' then k = '"'..k..'"' end
         s = s .. '['..k..'] = ' .. dump(v) .. ','
      end
      return s .. '} '
   else
      return tostring(o)
   end
end
`;

export function isValidLuaIdent(str: string): boolean {
    return !!str.match(/^[A-Za-z_][A-Za-z0-9_]+$/);
}
function uuidToIdent(name: string, nameHint?: string): string {
    const uuidPart = "_" + name.replaceAll("-", "_");
    if (nameHint && isValidLuaIdent(nameHint)) return nameHint + uuidPart;
    return uuidPart;
}
class Ctx {
    uuidToIdentMap = new Map<UUID, string>();
    nextIdentId= 0;
    uuidToNumberMap = new Map<UUID, number>();
    nextUuidNumber = 0;

    addUuidIdent(uuid: UUID, nameHint?: string): string {
        const name = uuidToIdent(""+this.nextIdentId++, nameHint);
        if(this.uuidToIdentMap.has(uuid)) {
            throw new Error("already has");
        }
        this.uuidToIdentMap.set(uuid, name);
        return name;
    }
    addTrueUuidIdent(uuid: UUID, nameHint?: string): string {
        const name = uuidToIdent(""+this.nextIdentId+++"_"+uuid, nameHint);
        if(this.uuidToIdentMap.has(uuid)) {
            throw new Error("already has");
        }
        this.uuidToIdentMap.set(uuid, name);
        return name;
    }
    addNextIdent(nameHint?: string): string {
        return uuidToIdent(""+this.nextIdentId++, nameHint);
    }
    getUuidIdent(uuid: UUID): string | null {
        const result = this.uuidToIdentMap.get(uuid);
        if(!result) return null;
        return result;
    }
    uuidToNumber(uuid: UUID): number {
        if(this.uuidToNumberMap.has(uuid)) return this.uuidToNumberMap.get(uuid)!;
        const num = this.nextUuidNumber++;
        this.uuidToNumberMap.set(uuid, num);
        return num;
    }
}
function luaString(str: string): string {
    return JSON.stringify(str);
}

export function generateLua(avatar: Avatar) {
    const header = getHeader(avatar);
    try {
        return header + generateLuaInner(avatar);
    }catch(e){
        return header + `\nprint(${luaString("figuraeditor bug! "+(e instanceof Error ? e : new Error("" + e)).toString())})\n`;
    }
}
export function generateLuaInner(avatar: Avatar) {
    const ctx = new Ctx();
    const warnEnabled = true;
    let alwaysWarnings = ``;
    
    let fns = ``;

    let mainVars = `\n-- Setup vars\n`;
    let src = "";


    const textureVars = new Map<string, string>();
    let getTexture = (texture: string): string => {
        if(textureVars.has(texture)) return textureVars.get(texture)!;
        const val = ctx.addNextIdent(texture);
        mainVars += `local ${val} = textures[${luaString(texture)}]\n`;
        if(warnEnabled) mainVars += `if not ${val} then print(${luaString("Invalid texture: "+texture)}) end\n`;
        textureVars.set(texture, val);
        return val;
    };
    const modelPartVars = new Map<string, string>();
    let getModelPart = (modelPart: string): string => {
        if(modelPartVars.has(modelPart)) return modelPartVars.get(modelPart)!;
        const val = ctx.addNextIdent(modelPart);
        mainVars += `local status, ${val} = pcall(function() return ${modelPart} end)\n`;
        mainVars += `if not status then ${val} = nil end\n`;
        if(warnEnabled) mainVars += `if not ${val} then print(${luaString("Invalid model part: "+modelPart)}) end\n`;
        modelPartVars.set(modelPart, val);
        return val;
    };
    const animationVars = new Map<string, string>();
    let getAnimation = (animation: string): string => {
        if(animationVars.has(animation)) return animationVars.get(animation)!;
        const val = ctx.addNextIdent(animation);
        mainVars += `local status, ${val} = pcall(function() return ${animation} end)\n`;
        mainVars += `if not status then ${val} = nil end\n`;
        if(warnEnabled) mainVars += `if not ${val} then print(${luaString("Invalid animation: "+animation)}) end\n`;
        animationVars.set(animation, val);
        return val;
    };
    type ToggleGroup = {ping: string, activeState: string};
    const toggleGroups = new Map<UUID, ToggleGroup>();
    let getToggleGroup = (toggleGroup: UUID): ToggleGroup => {
        if(toggleGroups.has(toggleGroup)) return toggleGroups.get(toggleGroup)!;
        const activeState = ctx.addNextIdent(toggleGroup);
        const ping = "pings.actionEditor_"+ctx.addTrueUuidIdent(toggleGroup);
        fns += `local ${activeState} = nil\n`;
        fns += `function ${ping}(nextState)\n`;
        fns += `    ${activeState} = nextState\n`;
        fns += `end\n`;
        const g: ToggleGroup = {ping, activeState};
        toggleGroups.set(toggleGroup, g);
        return g;
    };

    src += `\n-- Action wheels\n`;
    for(const actionWheel of Object.values(avatar.actionWheels)) {
        const name = ctx.addUuidIdent(actionWheel.uuid, actionWheel.title);
        src += `local ${name} = action_wheel:newPage()\n`;
    }
    src += `\n-- Action wheel actions\n`;
    for(const actionWheel of Object.values(avatar.actionWheels)) {
        const actionWheelIdent = ctx.getUuidIdent(actionWheel.uuid);
        if(!actionWheelIdent) continue;
        for(const action of actionWheel.actions) {
            const actionIdent = ctx.addUuidIdent(action.uuid);
            src += `local ${actionIdent} = ${actionWheelIdent}:newAction()\n`;
            src += `${actionIdent}:title(${luaString(action.label)})\n`;
            if(action.icon.type === "item") {
                src += `${actionIdent}:item(${luaString(action.icon.id)})\n`;
            }else if(action.icon.type === "texture") {
                const texVar = getTexture(action.icon.file);
                src += `if ${texVar} then ${actionIdent}:texture(${texVar}, ${action.icon.u}, ${action.icon.v}, ${action.icon.width}, ${action.icon.height}, ${action.icon.scale}) end\n`;
            }else{
                // no icon
            }
            src += `${actionIdent}:hoverColor(${action.color[0]} / 255, ${action.color[1]} / 255, ${action.color[2]} / 255)\n`;
            if(action.effect?.kind === "toggle" && action.effect.toggleGroup != null && action.effect.value != null) {
                const toggleGroup = getToggleGroup(action.effect.toggleGroup);
                const num = ctx.uuidToNumber(action.effect.value);
                src += `${actionIdent}:onLeftClick(function()\n`;
                src += `    if ${toggleGroup.activeState} == ${num} then\n`;
                src += `        print("set false")\n`;
                src += `        ${toggleGroup.ping}(nil)\n`;
                src += `    else\n`;
                src += `        ${toggleGroup.ping}(${num})\n`;
                src += `    end\n`;
                src += `end)\n`;
            }else if(action.effect?.kind === "switchPage") {

            }else{
                // no effect
            }
        }
    }
    src += `\n-- Action wheel main\n`;
    const mainName = avatar.mainActionWheel ? ctx.getUuidIdent(avatar.mainActionWheel) : null;
    if(mainName) {
        src += `action_wheel:setPage(${mainName})\n`;
    }
    src += "\nprintTable('loaded')";

    
    src += `\n-- Render event\n`;
    src += `function events.render(delta, context)\n`;
    let renderVars = "";
    let renderContents = "";

    const addCondition = (cond: Condition): string | null => {
        console.log(cond);
        if(cond.kind === "toggleGroup") {
            if(!cond.toggleGroup) return "false";
            if(!cond.value) return "false";
            const toggleGroup = getToggleGroup(cond.toggleGroup);
            return `${toggleGroup.activeState} == ${ctx.uuidToNumber(cond.value)}`
        }else{
            alwaysWarnings += `print("TODO implement condition ${cond.kind}")\n`;
            return "false";
        }
    };
    
    for(const setting of Object.values(avatar.conditionalSettings)) {
        if(!setting.activationCondition) continue;

        const cond = addCondition(setting.activationCondition);
        if(setting.kind === "play_animation") {
            const anim = getAnimation(setting.animation);
            renderContents += `    if ${anim} then ${anim}:setPlaying(${cond}) end\n`;
            // TODO remove this
            renderContents += `    if ${cond} then renderer:setOffsetCameraPivot(0, -0.5, 0) else renderer:setOffsetCameraPivot(0, 0, 0) end\n`;
        }else{
            alwaysWarnings += `print("TODO implement setting ${setting.kind}")\n`;
        }
    }
    src += renderVars;
    src += renderContents;
    src += `end\n`;

    return fns + mainVars + src + alwaysWarnings;
}

export function parseLua(source: string): Avatar {
    const dmsplit = source.split("-- %__DATA_MARKER__%");
    if(dmsplit.length !== 3) throw new Error("Invalid or corrupted source");
    return JSON.parse(dmsplit[1].split("\n").map(l => l.startsWith("--") ? l.slice(2) : l).join("\n"));
}