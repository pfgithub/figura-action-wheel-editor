import type {
	ActionEffect,
	AnimationRef,
	Avatar,
	Condition,
	UUID,
} from "@/types";

/*
Use Store to store the values
https://figura-wiki.pages.dev/globals/Avatar#store
store(key, value)

Sample code

local mainPage = action_wheel:newPage()
action_wheel:setPage(mainPage)


function pings.bowl()
    animations.model.test1:play()

end


local action = mainPage:newAction()
    :title("Test action1")
    :item("minecraft:dirt")
    :hoverColor(1, 0, 1)
    :onLeftClick(pings.bowl)

vanilla_model.PLAYER:setVisible(false)

function events.tick()
    local crouching = player:getPose() == "CROUCHING"
    local sprinting = player:isSprinting()
    local blocking = player:isBlocking()
    local fishing = player:isFishing()
    local sleeping = player:getPose() == "SLEEPING"
    local swimming = player:getPose() == "SWIMMING"
    local flying = player:getPose() == "FALL_FLYING"
    local walking = player:getVelocity().xz:length() > .01

    animations.model.i:setPlaying(not walking and not crouching)
end

*/

const getHeader = (avatar: Avatar) => /* lua */ `
--------------------------------------
-- This file is generated by --
-- https://pfg.pw/figura-action-wheel-editor

-- Edit it at the website.
--------------------------------------


-- %__DATA_MARKER__%
${JSON.stringify(avatar, null, 2)
	.split("\n")
	.map((l) => `-- ${l}`)
	.join("\n")}
-- %__DATA_MARKER__%


local function dump(o)
   if type(o) == 'table' then
      local s = '{ '
      for k,v in pairs(o) do
         if type(k) ~= 'number' then k = '"'..k..'"' end
         s = s .. '['..k..'] = ' .. dump(v) .. ','
      end
      return s .. '} '
   else
      return tostring(o)
   end
end

-- on error return nil. warn on error or nil.
local function tryOrNil(cb, name)
    local status, value = pcall(cb)
    if not status then value = nil end
    if not value and name then print("Invalid model part: "..name) end
    return value
end

`;

export function isValidLuaIdent(str: string): boolean {
	return !!str.match(/^[A-Za-z_][A-Za-z0-9_]+$/);
}
function uuidToIdent(name: string, nameHint?: string): string {
	const uuidPart = `_${name.replaceAll("-", "_")}`;
	if (nameHint && isValidLuaIdent(nameHint)) return nameHint + uuidPart;
	return uuidPart;
}
class Ctx {
	uuidToIdentMap = new Map<UUID, string>();
	nextIdentId = 0;
	uuidToNumberMap = new Map<UUID, number>();
	nextUuidNumber = 0;

	addUuidIdent(uuid: UUID, nameHint?: string): string {
		const name = uuidToIdent(`${this.nextIdentId++}`, nameHint);
		if (this.uuidToIdentMap.has(uuid)) {
			throw new Error("already has");
		}
		this.uuidToIdentMap.set(uuid, name);
		return name;
	}
	addTrueUuidIdent(uuid: UUID, nameHint?: string): string {
		const name = uuidToIdent(`${this.nextIdentId++}_${uuid}`, nameHint);
		if (this.uuidToIdentMap.has(uuid)) {
			throw new Error("already has");
		}
		this.uuidToIdentMap.set(uuid, name);
		return name;
	}
	addNextIdent(nameHint?: string): string {
		return uuidToIdent(`${this.nextIdentId++}`, nameHint);
	}
	getUuidIdent(uuid: UUID): Lua | null {
		const result = this.uuidToIdentMap.get(uuid);
		if (!result) return null;
		return result;
	}
	uuidToNumber(uuid: UUID): number {
		if (this.uuidToNumberMap.has(uuid)) return this.uuidToNumberMap.get(uuid)!;
		const num = this.nextUuidNumber++;
		this.uuidToNumberMap.set(uuid, num);
		return num;
	}
}
function luaString(str: string): string {
	return JSON.stringify(str);
}

const stringifyPart = (part: string) => {
	if (!isValidLuaIdent(part)) {
		return `[${JSON.stringify(part)}]`;
	}
	return `.${part}`;
};

function stringifyParts(parts: string[]): string {
	return parts.map(stringifyPart).join("");
}

function memo<U, T>(cb: (src: U) => T): (src: NoInfer<U>) => NoInfer<T> {
	const map = new Map<U, T>();
	return (src) => {
		if (!map.has(src)) map.set(src, cb(src));
		return map.get(src)!;
	};
}

// statement | expression(prec)
// if expression(3) inserted into slot(4), it needs parens
type Lua = string | number | Lua[];
function lua(a: TemplateStringsArray, ...b: Lua[]): Lua {
	const res: Lua[] = [];
	for (let i = 0; i < a.length; i++) {
		res.push(a[i]);
		b[i] && res.push(b[i]);
	}
	return res;
}
export function generateLua(avatar: Avatar) {
	const header = getHeader(avatar);
	try {
		return header + generateLuaInner(avatar);
	} catch (e) {
		return (
			header +
			`\nprint(${luaString(`figuraeditor bug! ${(e instanceof Error ? e : new Error(`${e}`)).toString()}`)})\n`
		);
	}
}
export function generateLuaInner(avatar: Avatar) {
	const ctx = new Ctx();
	const warnEnabled = true;
	const src: Lua[] = [];
	const alwaysWarnings: Lua[] = [];
	src.push(alwaysWarnings);
	const addWarning = (msg: string) => {
		if (!warnEnabled) return;
		alwaysWarnings.push(lua`print(${luaString(msg)})\n`);
	};

	const fns: Lua[] = [];
	src.push(fns);
	const predeclare: Lua[] = [];
	src.push(predeclare);

	const mainVars: Lua[] = [`\n-- Setup vars\n`];

	const getTexture = memo((texture: string): string => {
		const val = ctx.addNextIdent(texture);
		mainVars.push(
			`local ${val} = tryOrNil(function() return textures[${luaString(texture)}] end, ${luaString(texture)})\n`,
		);
		return val;
	});
	const getModelPart = memo((modelPart: string): string => {
		const val = ctx.addNextIdent(modelPart);
		mainVars.push(
			`local ${val} = tryOrNil(function() return ${modelPart} end, ${warnEnabled ? luaString(modelPart) : null})\n`,
		);
		return val;
	});
	type AnimationStr = string & { __is_animation_str: true };
	const _astr = (animation: AnimationRef): AnimationStr => {
		return `animations${stringifyParts([animation.model, animation.animation])}` as AnimationStr;
	};
	const _getAnimation = memo((animation: AnimationStr): Lua => {
		const val = ctx.addNextIdent(animation);
		mainVars.push(
			`local ${val} = tryOrNil(function() return ${animation} end, ${luaString(animation)})\n`,
		);
		return val;
	});
	type ToggleGroup = {
		toggler: string;
		ping: string;
		activeState: string;
		onToggled: Lua[];
	};
	const _getToggleGroup = memo((toggleGroup: UUID): ToggleGroup => {
		const activeState = ctx.addNextIdent(toggleGroup);
		const ping = `pings.actionEditor_${ctx.addTrueUuidIdent(toggleGroup)}`;
		fns.push(`local ${activeState} = nil\n`);
		fns.push(`function ${ping}(nextState)\n`);
		fns.push(`    ${activeState} = nextState\n`);
		const onToggled: Lua[] = [];
		fns.push(onToggled);
		fns.push(`end\n`);
		const toggler = ctx.addNextIdent(toggleGroup);
		const ret: ToggleGroup = { toggler, ping, activeState, onToggled };
		return ret;
	});
	type Effect = {
		callEffect: (state: Lua) => Lua;
		state?: { get: Lua; onChange: (callback: Lua) => void };
	};
	const getEffect = memo((effect: ActionEffect): Effect => {
		const none: Effect = {
			callEffect() {
				return "--";
			},
		};
		// if(effect.kind === "toggle" && effect.toggleGroup) {
		// 	const toggleGroup = getToggleGroup(effect.toggleGroup);
		// 	const num =
		// 		effect.value == null
		// 			? "nil"
		// 			: ctx.uuidToNumber(effect.value);
		// 	return {
		// 		callEffect(state) {
		// 			return `${toggleGroup.ping}((${state}) and ${num} or nil)`;
		// 		},
		// 		state: {
		// 			get: `(${toggleGroup.activeState} == ${num})`,
		// 			onChange: (callback) => toggleGroup.onToggled.push(`    ${callback}\n`),
		// 		},
		// 	};
		if (effect.kind === "switchPage" && effect.actionWheel != null) {
			const actionWheel = ctx.getUuidIdent(effect.actionWheel);
			if (!actionWheel) {
				addWarning(`switchPage missing action wheel`);
				return none;
			}
			return {
				callEffect(state) {
					return lua`if ${state} then action_wheel:setPage(${actionWheel}) end`;
				},
			};
			// }else if(effect.kind === "toggleAnimation" && effect.animation != null) {
			// 	const animation = getAnimation(astr(effect.animation));
			// 	return {
			// 		callEffect(state) {
			// 			return `${animation}:setPlaying(${state})`;
			// 		},
			// 		state: {
			// 			get: `${animation}:isPlaying()`,
			// 			onChange: () => {
			// 				addWarning(`TODO implement animation state events?`);
			// 			},
			// 		},
			// 	};
		} else {
			addWarning(`TODO implement effect ${effect.kind}`);
			return none;
		}
		// const effectFn = ctx.addNextIdent();
		// fns.push(`local function ${effectFn}(state)\n`);
		// fns.push(`    if state then `);
		// fns.push(`end\n`);
	});

	src.push(lua`\n-- Action wheels\n`);
	for (const actionWheel of Object.values(avatar.actionWheels)) {
		const name = ctx.addUuidIdent(actionWheel.uuid, actionWheel.title);
		src.push(lua`local ${name} = action_wheel:newPage()\n`);
	}
	src.push(lua`\n-- Action wheel actions\n`);
	for (const actionWheel of Object.values(avatar.actionWheels)) {
		const actionWheelIdent = ctx.getUuidIdent(actionWheel.uuid);
		if (!actionWheelIdent) continue;
		for (const action of actionWheel.actions) {
			const actionIdent = ctx.addUuidIdent(action.uuid);
			predeclare.push(`local ${actionIdent} = nil\n`);
			src.push(lua`${actionIdent} = ${actionWheelIdent}:newAction()\n`);
			src.push(lua`${actionIdent}:title(${luaString(action.label)})\n`);
			if (action.icon.type === "item") {
				src.push(lua`${actionIdent}:item(${luaString(action.icon.id)})\n`);
			} else if (action.icon.type === "texture") {
				const texVar = getTexture(action.icon.file);
				src.push(
					lua`if ${texVar} then ${actionIdent}:texture(${texVar}, ${action.icon.u}, ${action.icon.v}, ${action.icon.width}, ${action.icon.height}, ${action.icon.scale}) end\n`,
				);
			} else {
				// no icon
			}
			src.push(
				`${actionIdent}:hoverColor(${action.color[0]} / 255, ${action.color[1]} / 255, ${action.color[2]} / 255)\n`,
			);
			src.push(`${actionIdent}:onToggle(function(toggled)\n`);
			for (const effect of action.effects ?? []) {
				const fx = getEffect(effect);
				src.push(lua`    ${fx.callEffect(lua`toggled`)}\n`);
			}
			const toggleState = action.effects?.[0];
			if (toggleState) {
				const fx = getEffect(toggleState);
				if (fx.state) {
					fx.state.onChange(`${actionIdent}:toggled(${fx.state.get})`);
				}
			}
			src.push(`end)\n`);
		}
	}
	src.push(`\n-- Action wheel main\n`);
	const mainName = avatar.mainActionWheel
		? ctx.getUuidIdent(avatar.mainActionWheel)
		: null;
	if (mainName) {
		src.push(`action_wheel:setPage(${mainName})\n`);
	}

	src.push(`\n-- Render event\n`);
	src.push(`function events.render(delta, context)\n`);
	const renderVars: Lua[] = [];
	const renderContents: Lua[] = [];

	const renderIdToVarMap = new Map<string, string>();
	enum UpdateFrequencyKind {
		init = 0,
		toggleGroupChanged = 1,
		tick = 2,
		render = 3,
	}
	type UpdateFrequency =
		| {
				// it is run once, at init
				kind: UpdateFrequencyKind.init;
		  }
		| {
				// it is run at init and every time any of the specified toggle groups change
				kind: UpdateFrequencyKind.toggleGroupChanged;
				groups: UUID[];
		  }
		| {
				// it is run every tick
				kind: UpdateFrequencyKind.tick;
		  }
		| {
				// it is run every render
				kind: UpdateFrequencyKind.render;
		  };
	function mergeUpdateFrequency(
		a: UpdateFrequency,
		b: UpdateFrequency,
	): UpdateFrequency {
		if (a.kind > b.kind) return a;
		if (b.kind > a.kind) return b;
		if (
			a.kind === UpdateFrequencyKind.toggleGroupChanged &&
			b.kind === UpdateFrequencyKind.toggleGroupChanged
		) {
			return {
				kind: UpdateFrequencyKind.toggleGroupChanged,
				groups: [...new Set([...a.groups, ...b.groups])],
			};
		}
		return a;
	}
	const _getUpdateFrequency = (cond: Condition): UpdateFrequency => {
		// if (cond.kind === "toggleGroup" && cond.toggleGroup) {
		// 	return {
		// 		kind: UpdateFrequencyKind.toggleGroupChanged,
		// 		groups: [cond.toggleGroup],
		// 	};
		if (cond.kind === "render" && cond.render != null) {
			// TODO: not all of these need to be every render, just a few
			return { kind: UpdateFrequencyKind.render };
		} else if (cond.kind === "and" || cond.kind === "or") {
			return cond.conditions.reduce<UpdateFrequency>(
				(t, a) => mergeUpdateFrequency(t, _getUpdateFrequency(a)),
				{ kind: UpdateFrequencyKind.init },
			);
		} else if (cond.kind === "not" && cond.condition) {
			return _getUpdateFrequency(cond.condition);
		} else if (cond.kind === "animation") {
			// maybe should be tick or animation state changed?
			return { kind: UpdateFrequencyKind.render };
		} else {
			return { kind: UpdateFrequencyKind.init };
		}
	};
	// todo these will need seperate caches per point they can be inserted at
	const addCondition = (cond: Condition): string => {
		// if (cond.kind === "toggleGroup") {
		// 	if (!cond.toggleGroup) return "false";
		// 	const toggleGroup = getToggleGroup(cond.toggleGroup);
		// 	return `${toggleGroup.activeState} == ${cond.value == null ? "nil" : ctx.uuidToNumber(cond.value)}`;
		if (cond.kind === "render" && cond.render != null) {
			if (renderIdToVarMap.has(cond.render))
				return renderIdToVarMap.get(cond.render)!;
			if (cond.render === "playerIsFlying") {
				// fly detection
				mainVars.push(`playerIsFlying = false
do
  local wasFlying = false
  function pings.setPlayerIsFlying(value)
    playerIsFlying = value
  end
  if host:isHost() then
    function events.tick()
      playerIsFlying = host:isFlying()
      if wasFlying ~= playerIsFlying then
        pings.setPlayerIsFlying(playerIsFlying)
      end
      wasFlying = playerIsFlying
    end
  end
end
`);
				renderIdToVarMap.set(cond.render, "playerIsFlying");
				return "playerIsFlying";
			}
			const varId = ctx.addNextIdent(cond.render);
			renderVars.push(`    local ${varId} = ${cond.render}\n`);
			renderIdToVarMap.set(cond.render, varId);
			return varId;
		} else if (cond.kind === "and") {
			return cond.conditions
				.map((cond) => `(${addCondition(cond)})`)
				.join(" and ");
		} else if (cond.kind === "or") {
			return cond.conditions
				.map((cond) => `(${addCondition(cond)})`)
				.join(" or ");
		} else if (cond.kind === "not") {
			if (!cond.condition) return "false";
			return `not (${addCondition(cond.condition)})`;
		} else {
			addWarning(`TODO implement condition ${cond.kind}`);
			return "false";
		}
	};

	for (const setting of Object.values(avatar.conditionalSettings)) {
		if (!setting.activationCondition) continue;

		const cond = addCondition(setting.activationCondition);
		if (setting.kind === "hide_element") {
			const elem = getModelPart(
				"models" +
					stringifyParts([setting.element.model, ...setting.element.partPath]),
			);
			renderContents.push(
				`    if ${elem} then ${elem}:setVisible(${cond}) end\n`,
			);
		} else {
			addWarning(`TODO implement ${setting.kind}`);
		}
	}
	src.push(renderVars);
	src.push(renderContents);
	src.push(`end\n`);

	// animation state machine
	// for (const state of Object.values(avatar.animationLayers ?? {})) {
	// 	const varname = ctx.addNextIdent(state.name);
	// 	predeclare.push(`local ${varname} = ${ctx.uuidToNumber(state.noneNode)}`);
	// 	// we can consider supporting saving animation states

	// 	// call noneNode's animationStartFn on init

	// 	for (const node of Object.values(state.nodes)) {
	// 		const _num = ctx.uuidToNumber(node.uuid);

	// 		for (const transition of node.transitions) {
	// 			if (transition.activationCondition == null) continue;

	// 			// to support waitForFinish, make the activation condition AND(animation done, existing condition)
	// 			const _updateFrequency = getUpdateFrequency(
	// 				transition.activationCondition,
	// 			);

	// 			// now we have to add the transition in two places:
	// 			// - unless updateFrequency is render then add it in thisAnimationStartFn
	// 			// - add it in the updatefrequency place
	// 			// which is:
	// 			// - fn checkAnimationNTransitionN()
	// 			//       if varname == num and activationCondition then
	// 			//           thisAnimationStopFn()
	// 			//           nextAnimationStartFn()
	// 			//       end
	// 			//   end
	// 			//   function thisAnimationStopFn()
	// 			//       thisAnimation:stop()
	// 			//   end
	// 			//   function nextAnimationStartFn()
	// 			//       nextAnimation:start()
	// 			//       run next animation action
	// 			//   end
	// 		}

	// 		// now for each condition we add it under (if animation state == this one) check condition
	// 	}
	// }

	return src.flat(Infinity as 1).join("");
}

export function parseLua(source: string): Avatar {
	const dmsplit = source.split("-- %__DATA_MARKER__%");
	if (dmsplit.length !== 3) throw new Error("Invalid or corrupted source");
	return JSON.parse(
		dmsplit[1]
			.split("\n")
			.map((l) => (l.startsWith("--") ? l.slice(2) : l))
			.join("\n"),
	);
}
